"""Subselect points from a full set of points."""
from __future__ import annotations

import ast
import subprocess
from pathlib import Path

import hydra
import numpy as np
import pandas as pd
from omegaconf import DictConfig, OmegaConf


def read_metadata(file_name: str) -> dict:
    """Read metadata generated by the subselection process.

    Parameters
    ----------
    file_name : str
        The metadata filename.

    Returns:
    -------
    dict
        n: Number of points.
        k: Subset size.
        dim: Dimension of the points.
        discrepancy: Discrepancy of the subset.
        runtime: Runtime of the subselection.
    """
    # n=1317,k=5,dim=3, discrepancy=0.421367, runtime=0.006542
    with open(file_name) as file:
        first_line = file.readline().strip()
    return ast.literaleval("dict(" + first_line + ")")

def extract_points_csv2txt(input_csv: str, output_txt: str) -> int:
    """Extract points from a csv file to a txt file.

    Parameters
    ----------
    input_csv : str
        Input points as csv with proper index.
    output_txt : str
        Same points but saved in a text file without index.

    Returns:
    -------
    int
        The number of points.
    """
    points = pd.read_csv(input_csv, index_col="problem_id")
    points.to_csv(output_txt, sep=" ", index=False, header=False)
    return len(points)

def _subselect(
        k: int, n_points: int,
        pointfile_txt_fn: str,
        subselectedpoints_txt_fn: str,
        metadata_fn: str,
        n_reps: int = 5000, executable: str = "./a.out",
        dimension: int = 3
    ) -> subprocess.CompletedProcess:
    """Subselect k points from a set of n_points.

    Parameters
    ----------
    k : int
        Subset size.
    n_points : int
        Number of points in the set.
    pointfile_txt_fn : str
        Source set of points.
    subselectedpoints_txt_fn : str
        Target filename of subset of points.
    metadata_fn : str
        Metadata filename.
    n_reps : int, optional
        Number of repetitions, by default 5000
    executable : str, optional
        The c executable to do the subselection (shift_v2nobrute.c), by default "./a.out"
    dimension : int, optional
        The dimensionality, by default 3

    Returns:
    -------
    subprocess.CompletedProcess
        Output of the subprocess.
    """
    command = f"export SHIFT_TRIES={n_reps}; {executable} {pointfile_txt_fn} {dimension} {n_points} "\
        f"{k} {subselectedpoints_txt_fn} {metadata_fn}"
    return subprocess.run(["bash", "-c", command], capture_output=True, text=True, check=False)  # noqa: S603,S607

def replace_ext(path: Path, ext: str) -> Path:
    """Replace the extension of a path.

    Parameters
    ----------
    path : Path
        Source path with extension.
    ext : str
        New extension.

    Returns:
    -------
    Path
        Source path with new extension.
    """
    return path.with_suffix(ext)

def split_sets(source_fn: str, subset_fn: str, subset_csv_fn: str, remaining_csv_fn: str) -> None:
    """Split the source set into a subset and a remaining set.

    Parameters
    ----------
    source_fn : str
        The source set of points.
    subset_fn : str
        The subset filename (no index).
    subset_csv_fn : str
        The subset csv filename with index/problem_ids.
    remaining_csv_fn : str
        The remaining points with index/problem_ids.
    """
    source_df = pd.read_csv(source_fn, index_col="problem_id")
    subset_df = pd.read_csv(subset_fn, sep=",", header=None, names=source_df.columns)
    subset_indices = []
    for _, subset_row in subset_df.iterrows():
        match_index = source_df[np.isclose(source_df, subset_row, atol=1e-6).all(axis=1)].index
        if not match_index.empty:
            subset_indices.append(match_index[0])
    assert subset_indices, "No matches found"
    subset_df.index = subset_indices
    subset_df.index.name = "problem_id"

    remaining_df = source_df.drop(subset_indices)
    subset_df.to_csv(subset_csv_fn)
    remaining_df.to_csv(remaining_csv_fn)

def subselect(
        k: int,
        workdir: str = "run-data",
        fullset_csv_fn: str = "df_crit.csv",
        n_reps: int = 5000,
        executable: str = "./a.out",
        n_subsets: int = 2
    ) -> pd.DataFrame:
    """Subselect from a full set of points.

    The subselection is iterative, with the full set being reduced by the selected points.

    Parameters
    ----------
    k : int
        The subset size.
    workdir : str, optional
        The working directory, by default "run-data"
    fullset_csv_fn : str, optional
        The filename of the full set of points, by default "df_crit.csv"
    n_reps : int, optional
        The number of repetitions for the subselection process, by default 5000
    executable : str, optional
        The c exectuable to do the subselection, by default "./a.out"
    n_subsets : int, optional
        The number of subsets to obatain, by default 2

    Returns:
    -------
    pd.DataFrame
        Subselection metadata:
            sourcepointset_fn: str
                The full set of points.
            subset_fn: str
                The subset of points.
            remainingset_fn: str
                The remaining points.
            n: int
                The number of points.
            k: int
                The subset size.
            dim: int
                The dimension of the points.
            discrepancy: float
                The discrepancy of the subset.
            runtime: float
                The runtime of the subselection.

    """
    workdir = Path(workdir)

    sourcepointset_fn = workdir / fullset_csv_fn

    results = []
    for i in range(n_subsets):
        print(f"Subset {i+1} of {n_subsets}")
        subset_fn = workdir / f"subset_{k}_{i}.csv"
        subset_fn_txt = replace_ext(subset_fn, ".txt")
        remainingset_fn = workdir / f"remaining_points_{k}_{i}.csv"
        replace_ext(remainingset_fn, ".txt")

        metadata_fn = workdir / f"metadata_{k}_{i}.txt"

        sourcepointset_fn_txt = replace_ext(sourcepointset_fn, ".txt")
        n_points = extract_points_csv2txt(sourcepointset_fn, sourcepointset_fn_txt)
        print("Subselect from ", sourcepointset_fn, " with ", n_points, " points")
        _subselect(k, n_points, sourcepointset_fn_txt, subset_fn_txt, metadata_fn, n_reps, executable)
        # print(subselect_result)
        split_sets(sourcepointset_fn, subset_fn_txt, subset_fn, remainingset_fn)

        result = {
            "sourcepointset_fn": sourcepointset_fn,
            "subset_fn": subset_fn,
            "remainingset_fn": remainingset_fn,
        }
        metadata = read_metadata(k, metadata_fn)
        result.update(metadata)

        print(result)
        results.append(result)

        sourcepointset_fn = remainingset_fn
    result_df = pd.DataFrame(results)
    result_df.to_csv(workdir / f"subselect_results_{k}.csv", index=False)
    return result_df


@hydra.main(config_path=".", config_name="config", version_base="1.1")
def main(cfg: DictConfig) -> pd.DataFrame:
    """Subselect from a full set of points.

    The subselection is iterative, with the full set being reduced by the selected points.
    All paths are relative to the current working directory.
    The full set is copied to the working directory.
    The results are saved in the hydra working directory.

    Parameters
    ----------
    cfg : DictConfig
        Configuration:
            k: 10: The subset size.
            fullset_csv_fn: "run-data/df_crit.csv": The location of the full set.
            n_reps: !!int 5000: The number of repetitions.
            executable: ./a.out: The executable to run to subselect points.
            n_subsets: 2: The number of subsets to create.

    Returns:
    -------
    pd.DataFrame
        Subselection metadata.
    """
    root_path = Path(hydra.utils.get_original_cwd())
    print(f"Root path: {root_path}")
    print(OmegaConf.to_yaml(cfg))
    hydra_work_dir = "."

    fullset_csv_fn_base = Path(cfg.fullset_csv_fn).stem + ".csv"
    # Copy source df_crit to work dir
    source_df = pd.read_csv(root_path / cfg.fullset_csv_fn)
    source_df.to_csv(Path(hydra_work_dir) / fullset_csv_fn_base, index=False)
    subselect(cfg.k, hydra_work_dir, fullset_csv_fn_base, cfg.n_reps, root_path / cfg.executable, cfg.n_subsets)

if __name__ == "__main__":
    main()

